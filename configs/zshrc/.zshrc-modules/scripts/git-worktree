#!/bin/bash

# =============================================================================
# Git Worktree Setup Script for Nest Repository
# Creates a new git worktree and copies over local configuration files
# =============================================================================

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Nest repository root - update this or set NEST_REPO_ROOT env var
REPO_ROOT="${NEST_REPO_ROOT:-$HOME/projects/nest}"

# Verify the repo exists
if [[ ! -d "$REPO_ROOT/.git" ]]; then
    echo -e "${RED}Error:${NC} Nest repository not found at $REPO_ROOT"
    echo "Set NEST_REPO_ROOT environment variable to your nest repo location"
    exit 1
fi

# Worktrees base directory
WORKTREES_DIR="$REPO_ROOT/.worktrees"

# =============================================================================
# Helper Functions
# =============================================================================

print_header() {
    echo -e "\n${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}‚ö†${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_info() {
    echo -e "${BLUE}‚Üí${NC} $1"
}

show_usage() {
    echo "Usage: nest-wt <worktree-name> [base-ref]"
    echo ""
    echo "Creates a new git worktree with local configuration files."
    echo "Always creates a new branch prefixed with 'jordan/'."
    echo ""
    echo "Arguments:"
    echo "  worktree-name     Name for the worktree directory (required)"
    echo "                    Branch will be created as 'jordan/<worktree-name>'"
    echo "  base-ref          What to branch from (optional):"
    echo "                    - Version number (2.11.0) -> release/2.11.0"
    echo "                    - Branch name (main, develop)"
    echo "                    - Remote ref (origin/some-branch)"
    echo "                    - Defaults to HEAD if not provided"
    echo ""
    echo "Examples:"
    echo "  nest-wt my-feature 2.11.0                  # jordan/my-feature from release/2.11.0"
    echo "  nest-wt hotfix 2.10.5                      # jordan/hotfix from release/2.10.5"
    echo "  nest-wt experiment main                   # jordan/experiment from main"
    echo "  nest-wt quick-fix                          # jordan/quick-fix from current HEAD"
    echo ""
    echo "The worktree will be created at: $WORKTREES_DIR/<worktree-name>"
    echo ""
    echo "Other commands:"
    echo "  nest-wt list                               # List all worktrees"
    echo "  nest-wt remove <number|name|path>          # Remove a worktree"
    echo "  nest-wt prune                              # Remove stale worktree references"
    echo ""
    echo "Remove examples:"
    echo "  nest-wt remove 1                           # Remove worktree #1 from list"
    echo "  nest-wt remove my-feature                  # Remove by name"
    echo "  nest-wt remove /full/path/to/worktree      # Remove by path"
}

copy_if_exists() {
    local src="$1"
    local dest="$2"
    local desc="$3"

    if [[ -e "$src" ]]; then
        if [[ -d "$src" ]]; then
            mkdir -p "$dest"
            cp -r "$src/." "$dest/"
        else
            mkdir -p "$(dirname "$dest")"
            cp "$src" "$dest"
        fi
        print_success "Copied $desc"
        return 0
    else
        print_warning "Skipped $desc (not found)"
        return 1
    fi
}

# =============================================================================
# Subcommands
# =============================================================================

wt_list() {
    cd "$REPO_ROOT"

    print_header "Nest Worktrees"

    local count=0
    local worktrees=()

    # Parse worktree list
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local path=$(echo "$line" | awk '{print $1}')
            local branch=$(echo "$line" | grep -o '\[.*\]' | tr -d '[]')
            worktrees+=("$path")
            count=$((count + 1))

            # Highlight .worktrees entries differently from main repo
            if [[ "$path" == *".worktrees"* ]]; then
                local name=$(basename "$path")
                echo -e "  ${GREEN}[$count]${NC} ${YELLOW}$name${NC}"
                echo -e "      Branch: $branch"
                echo -e "      Path:   $path"
                echo -e "      ${BLUE}nest-wt remove $path${NC}"
                echo ""
            else
                echo -e "  ${GREEN}[0]${NC} ${YELLOW}(main)${NC}"
                echo -e "      Branch: $branch"
                echo -e "      Path:   $path"
                echo ""
            fi
        fi
    done < <(git worktree list)

    if [[ $count -le 1 ]]; then
        echo -e "  ${YELLOW}No additional worktrees found.${NC}"
        echo ""
    fi

    # Check for prunable worktrees
    local prunable=$(git worktree list --porcelain | grep -c "prunable" || true)
    if [[ $prunable -gt 0 ]]; then
        echo -e "  ${YELLOW}‚ö† $prunable stale worktree(s) detected${NC}"
        echo -e "  Run ${BLUE}nest-wt prune${NC} to clean up"
        echo ""
    fi

    echo "Quick actions:"
    echo "  nest-wt remove <path>    # Remove a specific worktree"
    echo "  nest-wt prune            # Clean up stale references"
}

wt_remove() {
    local input=$1
    cd "$REPO_ROOT"

    if [[ -z "$input" ]]; then
        echo "Usage: nest-wt remove <number|path|name>"
        echo ""
        wt_list
        return 1
    fi

    local worktree_path=""

    # Check if input is a number
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        local count=0
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local path=$(echo "$line" | awk '{print $1}')
                # Skip main repo (index 0)
                if [[ "$path" == *".worktrees"* ]]; then
                    count=$((count + 1))
                    if [[ $count -eq $input ]]; then
                        worktree_path="$path"
                        break
                    fi
                fi
            fi
        done < <(git worktree list)

        if [[ -z "$worktree_path" ]]; then
            print_error "Invalid worktree number: $input"
            wt_list
            return 1
        fi
    # Check if input is a name (without path)
    elif [[ ! "$input" == /* ]]; then
        # Try to find by name in .worktrees directory
        local potential_path="$WORKTREES_DIR/$input"
        if [[ -d "$potential_path" ]]; then
            worktree_path="$potential_path"
        else
            print_error "Worktree not found: $input"
            wt_list
            return 1
        fi
    else
        worktree_path="$input"
    fi

    local name=$(basename "$worktree_path")
    local branch=$(cd "$worktree_path" 2>/dev/null && git branch --show-current)

    echo -e "Removing worktree: ${YELLOW}$name${NC}"
    echo -e "  Path:   $worktree_path"
    echo -e "  Branch: $branch"
    echo ""

    if git worktree remove "$worktree_path"; then
        print_success "Worktree removed: $name"

        # Offer to delete the branch too
        if [[ -n "$branch" ]]; then
            echo ""
            echo -e "Branch ${YELLOW}$branch${NC} still exists."
            echo -e "To delete it: ${BLUE}git branch -D $branch${NC}"
        fi
    else
        print_error "Failed to remove worktree"
        echo "Try: nest-wt remove --force $worktree_path"
    fi
}

wt_prune() {
    cd "$REPO_ROOT"
    echo "Checking for stale worktrees..."
    local stale_worktrees=$(git worktree list --porcelain | grep -B2 "prunable" | grep "worktree" | sed 's/worktree //')

    if [[ -z "$stale_worktrees" ]]; then
        echo "No stale worktrees found."
        return 0
    fi

    echo "Found stale worktrees:"
    echo "$stale_worktrees" | while read -r path; do
        echo "  - $path"
    done

    git worktree prune
    print_success "Pruned all stale worktree references"
}

wt_create() {
    local WORKTREE_NAME="$1"
    local BASE_REF="${2:-}"

    # Branch prefix for new branches
    local BRANCH_PREFIX="jordan/"
    local NEW_BRANCH="${BRANCH_PREFIX}${WORKTREE_NAME}"

    # Validate worktree name
    if [[ "$WORKTREE_NAME" =~ [^a-zA-Z0-9_-] ]]; then
        print_error "Worktree name should only contain letters, numbers, hyphens, and underscores"
        exit 1
    fi

    WORKTREE_PATH="$WORKTREES_DIR/$WORKTREE_NAME"

    print_header "Creating Git Worktree: $WORKTREE_NAME"

    # Show path info upfront and copy to clipboard
    echo -e "Worktree: ${GREEN}$WORKTREE_PATH${NC}"
    echo -e "Branch:   ${GREEN}$NEW_BRANCH${NC}"
    echo ""

    # Copy path to clipboard immediately (macOS)
    if command -v pbcopy &>/dev/null; then
        echo -n "$WORKTREE_PATH" | pbcopy
        echo -e "${BLUE}üìã Path copied to clipboard${NC}"
        echo ""
    fi

    # Check if worktree already exists
    if [[ -d "$WORKTREE_PATH" ]]; then
        print_error "Worktree directory already exists at: $WORKTREE_PATH"
        exit 1
    fi

    # Check if branch already exists
    cd "$REPO_ROOT"
    if git show-ref --verify --quiet "refs/heads/$NEW_BRANCH"; then
        print_warning "Branch '$NEW_BRANCH' already exists!"
        echo ""
        echo "Options:"
        echo "  1. Use existing branch:  git worktree add $WORKTREE_PATH $NEW_BRANCH"
        echo "  2. Delete old branch:    git branch -D $NEW_BRANCH"
        echo "  3. Use different name:   nest-wt <different-name> $BASE_REF"
        echo ""
        exit 1
    fi

    # Create worktrees directory if it doesn't exist
    mkdir -p "$WORKTREES_DIR"

    # Fetch latest from remote
    print_info "Fetching latest from origin..."
    git fetch origin

    # =========================================================================
    # Step 1: Create the worktree
    # =========================================================================

    print_info "Creating worktree..."

    if [[ -n "$BASE_REF" ]]; then
        local RESOLVED_REF=""

        # Check if it looks like a version number (e.g., 2.11.0)
        if [[ "$BASE_REF" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            # It's a version number, map to release/X.X.X
            local RELEASE_BRANCH="release/${BASE_REF}"
            if git show-ref --verify --quiet "refs/remotes/origin/$RELEASE_BRANCH"; then
                RESOLVED_REF="origin/$RELEASE_BRANCH"
                print_info "Resolved version $BASE_REF to $RESOLVED_REF"
            else
                print_error "Release branch not found: $RELEASE_BRANCH"
                print_info "Available release branches:"
                git branch -r | grep "origin/release/" | head -10
                exit 1
            fi
        # Check if it's already a remote ref
        elif [[ "$BASE_REF" == origin/* ]]; then
            RESOLVED_REF="$BASE_REF"
        # Check if release/X.X.X exists on remote
        elif git show-ref --verify --quiet "refs/remotes/origin/$BASE_REF"; then
            RESOLVED_REF="origin/$BASE_REF"
        # Check if it exists locally
        elif git show-ref --verify --quiet "refs/heads/$BASE_REF"; then
            RESOLVED_REF="$BASE_REF"
        else
            print_error "Could not find branch: $BASE_REF"
            exit 1
        fi

        # Create new branch from the resolved ref
        git worktree add "$WORKTREE_PATH" -b "$NEW_BRANCH" "$RESOLVED_REF"
        print_success "Created branch '$NEW_BRANCH' from '$RESOLVED_REF'"
    else
        # No base ref provided - create from current HEAD
        git worktree add "$WORKTREE_PATH" -b "$NEW_BRANCH"
        print_success "Created branch '$NEW_BRANCH' from HEAD"
    fi

    # =========================================================================
    # Step 2: Copy local configuration files
    # =========================================================================

    print_header "Copying Local Configuration Files"

    # --- .claude directory ---
    copy_if_exists "$REPO_ROOT/.claude" "$WORKTREE_PATH/.claude" ".claude/ (Claude Code settings)"

    # --- .vscode/settings.json ---
    if [[ -f "$REPO_ROOT/.vscode/settings.json" ]]; then
        mkdir -p "$WORKTREE_PATH/.vscode"
        cp "$REPO_ROOT/.vscode/settings.json" "$WORKTREE_PATH/.vscode/settings.json"
        print_success "Copied .vscode/settings.json"
    fi

    # --- Environment files ---
    print_info "Copying environment files..."

    ENV_FILES=(
        "apps/backend/client-api/.env.local"
        "apps/backend/pdf-generation-service/.env.local"
        "apps/frontend/patient-navigator/.env.local"
        "apps/frontend/provider-portal/.env.local"
    )

    for env_file in "${ENV_FILES[@]}"; do
        copy_if_exists "$REPO_ROOT/$env_file" "$WORKTREE_PATH/$env_file" "$env_file"
    done

    # --- Certificate files (*.pem) ---
    print_info "Copying certificate files..."

    PEM_DIRS=(
        "apps/backend/client-api"
        "apps/frontend/patient-navigator"
        "apps/frontend/provider-portal"
    )

    for pem_dir in "${PEM_DIRS[@]}"; do
        # Copy *.pem files in the app root
        for pem_file in "$REPO_ROOT/$pem_dir"/*.pem; do
            if [[ -f "$pem_file" ]]; then
                filename=$(basename "$pem_file")
                copy_if_exists "$pem_file" "$WORKTREE_PATH/$pem_dir/$filename" "$pem_dir/$filename"
            fi
        done

        # Copy certs/ directory if it exists
        if [[ -d "$REPO_ROOT/$pem_dir/certs" ]]; then
            mkdir -p "$WORKTREE_PATH/$pem_dir/certs"
            cp -r "$REPO_ROOT/$pem_dir/certs/"*.pem "$WORKTREE_PATH/$pem_dir/certs/" 2>/dev/null && \
                print_success "Copied $pem_dir/certs/*.pem" || \
                print_warning "No .pem files in $pem_dir/certs/"
        fi
    done

    # --- .cursor directory ---
    copy_if_exists "$REPO_ROOT/.cursor" "$WORKTREE_PATH/.cursor" ".cursor/ (Cursor IDE settings)"

    # --- .playwright-mcp directory ---
    copy_if_exists "$REPO_ROOT/.playwright-mcp" "$WORKTREE_PATH/.playwright-mcp" ".playwright-mcp/ (Playwright MCP config)"

    # =========================================================================
    # Step 3: Install dependencies
    # =========================================================================

    print_header "Installing Dependencies"

    cd "$WORKTREE_PATH"

    print_info "Running pnpm install (this may take a few minutes)..."
    if pnpm install; then
        print_success "Dependencies installed successfully"
    else
        print_error "Failed to install dependencies"
        print_warning "You may need to run 'pnpm install' manually in the worktree"
    fi

    # =========================================================================
    # Summary
    # =========================================================================

    print_header "Worktree Created Successfully!"

    echo "Quick start:"
    echo "  nx serve provider-portal   # Start Provider Portal"
    echo "  nx serve patient-navigator # Start Patient Navigator"
    echo "  nx serve client-api        # Start Client API"
    echo ""
    echo "To remove this worktree later:"
    echo "  nest-wt remove $WORKTREE_PATH"
    echo ""

    # Output path for wrapper function to cd into
    echo "WORKTREE_PATH:$WORKTREE_PATH"
}

# =============================================================================
# Main Entry Point
# =============================================================================

case "${1:-}" in
    list)
        wt_list
        ;;
    remove)
        shift
        wt_remove "$@"
        ;;
    prune)
        wt_prune
        ;;
    help|--help|-h)
        show_usage
        ;;
    "")
        show_usage
        exit 1
        ;;
    *)
        wt_create "$@"
        ;;
esac
