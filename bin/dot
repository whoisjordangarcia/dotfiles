#!/bin/bash
#
# dot - Enhanced dotfiles management system
#
# Handles installation, updates, and configuration for different platforms and environments
# Supports auto-detection and interactive configuration

set -e

# Get script directories
parentDirectory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
dotfilesDirectory="$(cd "$(dirname "$parentDirectory")" && pwd -P)"
configFile="$dotfilesDirectory/.dotconfig"

# Color output functions
source "$dotfilesDirectory/script/common/log.sh"

# Configuration defaults
DEFAULT_NAME="Jordan Garcia"
DEFAULT_EMAIL_PERSONAL="arickho@gmail.com"
DEFAULT_EMAIL_WORK="jordan.arickhogarcia@nestgenomics.com"

detect_system() {
	local os_name=""
	local distro=""

	if [[ "$OSTYPE" == "darwin"* ]]; then
		os_name="mac"
	elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
		os_name="linux"
		# Detect Linux distribution
		if [ -f /etc/os-release ]; then
			. /etc/os-release
			case "$ID" in
			ubuntu) distro="ubuntu" ;;
			fedora) distro="fedora" ;;
			arch) distro="arch" ;;
			*) distro="unknown" ;;
			esac
		fi
	else
		os_name="unknown"
	fi

	echo "${os_name}_${distro}"
}

get_modules_from_script() {
	local script="$1"
	if [[ ! -f "$script" ]]; then
		return 1
	fi
	# Extract component_installation array entries
	grep -A 100 'component_installation=(' "$script" |
		grep -v '^#' |
		sed -n '/(/,/)/p' |
		grep -v '(' | grep -v ')' |
		sed 's/^[[:space:]]*//' |
		sed 's/#.*//' |
		grep -v '^$'
}

interactive_module_selection() {
	local system="${1:-$(auto_select_installation)}"
	local script="$dotfilesDirectory/script/${system}_installation.sh"

	if [[ ! -f "$script" ]]; then
		fail "Installation script not found: $script"
	fi

	# Get available modules
	local modules=()
	while IFS= read -r module; do
		modules+=("$module")
	done < <(get_modules_from_script "$script")

	if [[ ${#modules[@]} -eq 0 ]]; then
		fail "No modules found in $script"
	fi

	# Initialize selection state (all selected by default)
	local selected=()
	for ((i = 0; i < ${#modules[@]}; i++)); do
		selected[$i]=1
	done

	# Interactive selection loop
	while true; do
		clear
		header "Module Selection ($system)"
		echo ""
		echo "  Toggle modules with number keys, then press Enter to install"
		echo "  Press 'a' to select all, 'n' to select none, 'q' to quit"
		echo ""

		for ((i = 0; i < ${#modules[@]}; i++)); do
			local marker="[ ]"
			if [[ ${selected[$i]} -eq 1 ]]; then
				marker="[${GREEN}âœ“${RESET}]"
			fi
			printf "  %2d) %b %s\n" "$((i + 1))" "$marker" "${modules[$i]}"
		done

		echo ""
		prompt "Selection: "
		read -r choice

		case "$choice" in
		q | Q)
			info "Cancelled"
			exit 0
			;;
		a | A)
			for ((i = 0; i < ${#modules[@]}; i++)); do
				selected[$i]=1
			done
			;;
		n | N)
			for ((i = 0; i < ${#modules[@]}; i++)); do
				selected[$i]=0
			done
			;;
		"")
			# Enter pressed - run selected modules
			break
			;;
		*[0-9]*)
			# Toggle the selected number
			local num=$((choice - 1))
			if [[ $num -ge 0 && $num -lt ${#modules[@]} ]]; then
				if [[ ${selected[$num]} -eq 1 ]]; then
					selected[$num]=0
				else
					selected[$num]=1
				fi
			fi
			;;
		esac
	done

	# Build list of selected modules
	SELECTED_MODULES=()
	for ((i = 0; i < ${#modules[@]}; i++)); do
		if [[ ${selected[$i]} -eq 1 ]]; then
			SELECTED_MODULES+=("${modules[$i]}")
		fi
	done

	if [[ ${#SELECTED_MODULES[@]} -eq 0 ]]; then
		info "No modules selected"
		exit 0
	fi

	# Run selected modules
	echo ""
	header "Installing ${#SELECTED_MODULES[@]} modules"

	# Export configuration
	load_config
	export DOT_NAME DOT_EMAIL DOT_ENVIRONMENT DOT_SYSTEM DOT_YUBIKEY
	export WORK_ENV=""
	if [[ "$DOT_ENVIRONMENT" == "work" ]]; then
		export WORK_ENV="1"
		# Create work mode toggle file for zsh configuration
		touch "$HOME/.zshrc-work-mode"
	else
		# Remove work mode toggle file if exists (switching to personal)
		rm -f "$HOME/.zshrc-work-mode"
	fi

	cd "$dotfilesDirectory"
	for module in "${SELECTED_MODULES[@]}"; do
		section "$module"
		local script_path="./script/${module}/setup.sh"
		if [[ -f "$script_path" ]]; then
			source "$script_path"
		else
			info "Script for $module does not exist"
		fi
	done

	success "Module installation complete!"
}

load_config() {
	if [[ -f "$configFile" ]]; then
		source "$configFile"
	fi
}

save_config() {
	cat >"$configFile" <<EOF
# Dotfiles configuration
DOT_NAME="$DOT_NAME"
DOT_EMAIL="$DOT_EMAIL"
DOT_ENVIRONMENT="$DOT_ENVIRONMENT"
DOT_SYSTEM="$DOT_SYSTEM"
DOT_YUBIKEY="$DOT_YUBIKEY"
EOF
	info "Configuration saved to $configFile"
}

get_available_installations() {
	local installations=()
	for file in "$dotfilesDirectory/script"/*_installation.sh; do
		if [[ -f "$file" ]]; then
			local basename=$(basename "$file" .sh)
			local install_name=${basename%_installation}
			installations+=("$install_name")
		fi
	done
	printf '%s\n' "${installations[@]}"
}

auto_select_installation() {
	local detected=$(detect_system)
	local available_installations=($(get_available_installations))

	# Try exact match first
	for installation in "${available_installations[@]}"; do
		if [[ "$installation" == "$detected" ]]; then
			echo "$installation"
			return
		fi
	done

	# Try partial matches
	local os_part=$(echo "$detected" | cut -d'_' -f1)
	for installation in "${available_installations[@]}"; do
		if [[ "$installation" == *"$os_part"* ]]; then
			echo "$installation"
			return
		fi
	done

	echo ""
}

show_logo() {
	local logo_file="$dotfilesDirectory/art/logo"
	if [[ -f "$logo_file" ]]; then
		echo ""
		# Display logo in blue color
		while IFS= read -r line; do
			printf "${BLUE}%s${RESET}\n" "$line"
		done <"$logo_file"
		echo ""
	fi
}

interactive_setup() {
	show_logo
	header "Dotfiles Setup"

	# Load existing config
	load_config

	# Smart environment detection first
	local detected_system=$(detect_system)
	local auto_installation=$(auto_select_installation)
	local suggested_env="personal"

	# Smart environment detection based on existing git config
	if [[ "$(git config user.email 2>/dev/null)" == *"@nestgenomics.com" ]]; then
		suggested_env="work"
	fi

	# Single consolidated prompt for all info
	echo ""
	prompt "Name: "
	read input_name
	DOT_NAME="${input_name:-${DOT_NAME:-$DEFAULT_NAME}}"

	prompt "Environment (personal/work) [${suggested_env}]: "
	read env_choice
	env_choice="${env_choice:-$suggested_env}"

	case $env_choice in
	work | Work | w | W | 2)
		DOT_ENVIRONMENT="work"
		DOT_EMAIL="${DOT_EMAIL:-$DEFAULT_EMAIL_WORK}"
		;;
	*)
		DOT_ENVIRONMENT="personal"
		DOT_EMAIL="${DOT_EMAIL:-$DEFAULT_EMAIL_PERSONAL}"
		;;
	esac

	prompt "Email [${DOT_EMAIL}]: "
	read input_email
	DOT_EMAIL="${input_email:-$DOT_EMAIL}"

	echo ""
	if command -v gpg >/dev/null 2>&1; then
		echo "Current GPG keys:"
		gpg --list-secret-keys --keyid-format=long 2>/dev/null || echo "  No GPG keys found"
	else
		info "Install GPG and run: gpg --list-secret-keys --keyid-format=long"
	fi
	echo ""
	prompt "YubiKey ID (for git signing): "
	read input_yubikey
	DOT_YUBIKEY="${input_yubikey:-${DOT_YUBIKEY}}"

	# Auto-select installation with work variant
	if [[ -n "$auto_installation" ]]; then
		if [[ "$DOT_ENVIRONMENT" == "work" && -f "$dotfilesDirectory/script/${auto_installation%_*}_work_installation.sh" ]]; then
			auto_installation="${auto_installation%_*}_work"
		fi
		DOT_SYSTEM="$auto_installation"
	else
		DOT_SYSTEM="mac" # fallback
	fi

	# Clean summary
	echo ""
	header "Ready to Install"
	printf "  ${GREEN}Name:${RESET}         %s\n" "$DOT_NAME"
	printf "  ${GREEN}Email:${RESET}        %s\n" "$DOT_EMAIL"
	printf "  ${GREEN}Environment:${RESET}  %s\n" "$DOT_ENVIRONMENT"
	printf "  ${GREEN}System:${RESET}       %s\n" "$DOT_SYSTEM"
	printf "  ${GREEN}YubiKey:${RESET}      %s\n" "${DOT_YUBIKEY:-not set}"
	echo ""

	prompt "Continue? [Y/n]: "
	read proceed
	if [[ "$proceed" =~ ^[Nn]$ ]]; then
		echo ""
		info "Setup cancelled"
		exit 0
	fi

	save_config
}

run_installation() {
	local installation_script="$dotfilesDirectory/script/${DOT_SYSTEM}_installation.sh"

	if [[ ! -f "$installation_script" ]]; then
		fail "Installation script not found: $installation_script"
	fi

	# Export configuration for use by installation scripts
	export DOT_NAME DOT_EMAIL DOT_ENVIRONMENT DOT_SYSTEM DOT_YUBIKEY
	export WORK_ENV=""
	if [[ "$DOT_ENVIRONMENT" == "work" ]]; then
		export WORK_ENV="1"
		# Create work mode toggle file for zsh configuration
		touch "$HOME/.zshrc-work-mode"
		info "Work mode enabled (~/.zshrc-work-mode created)"
	else
		# Remove work mode toggle file if exists (switching to personal)
		rm -f "$HOME/.zshrc-work-mode"
	fi

	info "Running installation: $DOT_SYSTEM"
	exec "$installation_script"
}

displayUsageAndExit() {
	echo "dot -- Enhanced dotfiles management"
	echo ""
	echo "Usage: dot [options]"
	echo ""
	echo "Options:"
	echo "  -i, --install     Interactive installation setup"
	echo "  -m, --modules     Interactive module selection"
	echo "  -l, --list        List available installations"
	echo "  -s, --detect-system Show current system detection"
	echo "  -c, --config      Show current configuration"
	echo "  --reset-config    Reset configuration file"
	echo "  --reconfigure     Force re-input of configuration questions"
	echo "  -e, --edit        Open dotfiles directory for editing"
	echo "  -h, --help        Show this help message and exit"
	echo ""
	echo "Installation Examples:"
	echo "  dot -i                    # Interactive setup"
	echo "  dot -m                    # Select specific modules to install"
	echo "  dot --system mac --work   # Direct Mac work installation"
	echo "  dot --system linux_ubuntu # Direct Ubuntu installation"
	exit
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
	case "$1" in
	"-h" | "--help")
		displayUsageAndExit
		;;
	"-e" | "--edit")
		exec "${EDITOR:-code}" "$dotfilesDirectory"
		;;
	"-m" | "--modules")
		load_config
		interactive_module_selection "$DOT_SYSTEM"
		exit 0
		;;
	"-i" | "--install")
		FORCE_INTERACTIVE=1
		interactive_setup
		run_installation
		exit 0
		;;
	"-l" | "--list")
		info "Available installations:"
		get_available_installations
		exit 0
		;;
	"-s" | "--detect-system")
		detected=$(detect_system)
		auto=$(auto_select_installation)
		info "System Detection:"
		echo "  Detected: $detected"
		echo "  Recommended: ${auto:-none}"
		exit 0
		;;
	"-c" | "--config")
		load_config
		info "Current Configuration:"
		echo "  Name: ${DOT_NAME:-not set}"
		echo "  Email: ${DOT_EMAIL:-not set}"
		echo "  Environment: ${DOT_ENVIRONMENT:-not set}"
		echo "  System: ${DOT_SYSTEM:-not set}"
		echo "  YubiKey: ${DOT_YUBIKEY:-not set}"
		exit 0
		;;
	"--reset-config")
		rm -f "$configFile"
		info "Configuration reset"
		exit 0
		;;
	"--reconfigure")
		rm -f "$configFile"
		info "Configuration reset. Starting interactive setup..."
		interactive_setup
		run_installation
		exit 0
		;;
	"--system")
		shift
		DOT_SYSTEM="$1"
		;;
	"--work")
		DOT_ENVIRONMENT="work"
		;;
	"--personal")
		DOT_ENVIRONMENT="personal"
		;;
	*)
		echo "Invalid option: $1"
		displayUsageAndExit
		;;
	esac
	shift
done

# Default behavior - check if config exists, if not run interactive setup
load_config
if [[ -z "$DOT_SYSTEM" ]] || [[ "$FORCE_INTERACTIVE" == "1" ]]; then
	if [[ "$FORCE_INTERACTIVE" == "1" ]]; then
		info "Running interactive setup..."
	else
		info "No configuration found. Starting interactive setup..."
	fi
	interactive_setup
	run_installation
else
	show_logo
	header "Using Existing Configuration"
	printf "  ${GREEN}Name:${RESET}         %s\n" "$DOT_NAME"
	printf "  ${GREEN}Email:${RESET}        %s\n" "$DOT_EMAIL"
	printf "  ${GREEN}Environment:${RESET}  %s\n" "$DOT_ENVIRONMENT"
	printf "  ${GREEN}System:${RESET}       %s\n" "$DOT_SYSTEM"
	printf "  ${GREEN}YubiKey:${RESET}      %s\n" "${DOT_YUBIKEY:-not set}"
	echo ""

	prompt "Continue with this configuration? [Y/n]: "
	read proceed
	if [[ "$proceed" =~ ^[Nn]$ ]]; then
		echo ""
		info "Installation cancelled. Run 'dot --reconfigure' to change settings."
		exit 0
	fi

	run_installation
fi
