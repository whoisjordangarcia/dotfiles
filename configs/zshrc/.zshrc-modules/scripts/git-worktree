#!/bin/bash

# =============================================================================
# Git Worktree Setup Script for Nest Repository
# Creates a new git worktree and copies over local configuration files
# =============================================================================

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Nest repository root - update this or set NEST_REPO_ROOT env var
REPO_ROOT="${NEST_REPO_ROOT:-$HOME/projects/nest}"

# Verify the repo exists
if [[ ! -d "$REPO_ROOT/.git" ]]; then
    echo -e "${RED}Error:${NC} Nest repository not found at $REPO_ROOT"
    echo "Set NEST_REPO_ROOT environment variable to your nest repo location"
    exit 1
fi

# Worktrees base directory
WORKTREES_DIR="$REPO_ROOT/.worktrees"

# =============================================================================
# Helper Functions
# =============================================================================

print_header() {
    echo -e "\n${BLUE}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_info() {
    echo -e "${BLUE}→${NC} $1"
}

show_usage() {
    echo "Usage: nest-wt <worktree-name|branch-name> [base-ref]"
    echo ""
    echo "Creates a new git worktree with local configuration files."
    echo "Smart branch detection: reuses existing local/remote branches automatically."
    echo ""
    echo "Arguments:"
    echo "  worktree-name     Simple name → prefixed with 'jordan/'"
    echo "                    Full branch (contains /) → used as-is"
    echo "  base-ref          What to branch from (only for new branches):"
    echo "                    - Version number (2.11.0) -> release/2.11.0"
    echo "                    - Branch name (main, develop)"
    echo "                    - Remote ref (origin/some-branch)"
    echo "                    - Defaults to HEAD if not provided"
    echo ""
    echo "Examples:"
    echo "  nest-wt my-feature 2.11.0                  # jordan/my-feature from release/2.11.0"
    echo "  nest-wt my-feature                         # Reuses jordan/my-feature if exists"
    echo "  nest-wt jordan/my-feature                  # Same as above (slash detected)"
    echo "  nest-wt alice/her-feature                  # Checkout alice's branch (dir: alice-her-feature)"
    echo ""
    echo "The worktree will be created at: $WORKTREES_DIR/<worktree-name>"
    echo ""
    echo "Other commands:"
    echo "  nest-wt list                               # List all worktrees"
    echo "  nest-wt go                                 # Interactive worktree picker"
    echo "  nest-wt go <number|name>                   # Quick switch to worktree"
    echo "  nest-wt remove <number|name|path>          # Remove a worktree"
    echo "  nest-wt prune                              # Remove stale worktree references"
    echo ""
    echo "Quick switch examples:"
    echo "  nest-wt go 1                               # Switch to worktree #1"
    echo "  nest-wt go my-feature                      # Switch by name"
    echo "  wt                                         # Shortcut for 'nest-wt go'"
    echo ""
    echo "Remove examples:"
    echo "  nest-wt remove 1                           # Remove worktree #1 from list"
    echo "  nest-wt remove my-feature                  # Remove by name"
    echo "  nest-wt remove /full/path/to/worktree      # Remove by path"
}

copy_if_exists() {
    local src="$1"
    local dest="$2"
    local desc="$3"

    if [[ -e "$src" ]]; then
        if [[ -d "$src" ]]; then
            mkdir -p "$dest"
            cp -r "$src/." "$dest/"
        else
            mkdir -p "$(dirname "$dest")"
            cp "$src" "$dest"
        fi
        print_success "Copied $desc"
    else
        print_warning "Skipped $desc (not found)"
    fi
    # Always return 0 - skipping is not an error (avoids set -e exit)
    return 0
}

# =============================================================================
# Subcommands
# =============================================================================

wt_list() {
    cd "$REPO_ROOT"

    print_header "Nest Worktrees"

    local wt_count=0
    local total_count=0

    # Parse worktree list
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local path=$(echo "$line" | awk '{print $1}')
            local branch=$(echo "$line" | grep -o '\[.*\]' | tr -d '[]')
            total_count=$((total_count + 1))

            # Get git status info for this worktree
            local changes_info=""
            local ahead_behind=""
            local upstream_branch=""

            if [[ -d "$path" ]]; then
                # Count modified/staged/untracked files
                local modified=0 staged=0 untracked=0
                while IFS= read -r status_line; do
                    [[ -z "$status_line" ]] && continue
                    local xy="${status_line:0:2}"
                    # Staged changes (index)
                    [[ "${xy:0:1}" =~ [MADRC] ]] && staged=$((staged + 1))
                    # Unstaged changes (working tree)
                    [[ "${xy:1:1}" =~ [MD] ]] && modified=$((modified + 1))
                    # Untracked files
                    [[ "$xy" == "??" ]] && untracked=$((untracked + 1))
                done < <(git -C "$path" status --porcelain 2>/dev/null)

                # Build changes string
                local changes_parts=()
                [[ $staged -gt 0 ]] && changes_parts+=("${GREEN}+$staged staged${NC}")
                [[ $modified -gt 0 ]] && changes_parts+=("${YELLOW}~$modified modified${NC}")
                [[ $untracked -gt 0 ]] && changes_parts+=("${RED}?$untracked untracked${NC}")

                if [[ ${#changes_parts[@]} -gt 0 ]]; then
                    changes_info=$(IFS=", "; echo "${changes_parts[*]}")
                else
                    changes_info="${GREEN}clean${NC}"
                fi

                # Get ahead/behind info
                local upstream=$(git -C "$path" rev-parse --abbrev-ref "@{upstream}" 2>/dev/null || true)
                if [[ -n "$upstream" ]]; then
                    upstream_branch="$upstream"
                    local counts=$(git -C "$path" rev-list --left-right --count "$branch...$upstream" 2>/dev/null || echo "0 0")
                    local ahead=$(echo "$counts" | awk '{print $1}')
                    local behind=$(echo "$counts" | awk '{print $2}')

                    local ab_parts=()
                    [[ $ahead -gt 0 ]] && ab_parts+=("${GREEN}↑$ahead${NC}")
                    [[ $behind -gt 0 ]] && ab_parts+=("${RED}↓$behind${NC}")

                    if [[ ${#ab_parts[@]} -gt 0 ]]; then
                        ahead_behind=$(IFS=" "; echo "${ab_parts[*]}")
                    fi
                else
                    # Try to find the fork point / base branch
                    # Check common base branches
                    for base in "main" "develop" "master"; do
                        if git -C "$path" show-ref --verify --quiet "refs/heads/$base" 2>/dev/null || \
                           git -C "$path" show-ref --verify --quiet "refs/remotes/origin/$base" 2>/dev/null; then
                            local ref="origin/$base"
                            local fork_point=$(git -C "$path" merge-base "$branch" "$ref" 2>/dev/null || true)
                            if [[ -n "$fork_point" ]]; then
                                local ahead_of_base=$(git -C "$path" rev-list --count "$fork_point..$branch" 2>/dev/null || echo "0")
                                if [[ $ahead_of_base -gt 0 ]]; then
                                    upstream_branch="$base"
                                    ahead_behind="${GREEN}↑$ahead_of_base${NC} from $base"
                                    break
                                fi
                            fi
                        fi
                    done
                fi
            fi

            # Highlight .worktrees entries differently from main repo
            if [[ "$path" == *".worktrees"* ]]; then
                wt_count=$((wt_count + 1))
                local name=$(basename "$path")
                echo -e "  ${GREEN}[$wt_count]${NC} ${YELLOW}$name${NC}"
                echo -e "      Branch: $branch"
                [[ -n "$upstream_branch" ]] && echo -e "      From:   $upstream_branch"
                echo -e "      Status: $changes_info ${ahead_behind:+  $ahead_behind}"
                echo -e "      ${BLUE}nest-wt remove $wt_count${NC}"
                echo ""
            else
                echo -e "  ${GREEN}[0]${NC} ${YELLOW}(main)${NC}"
                echo -e "      Branch: $branch"
                echo -e "      Status: $changes_info ${ahead_behind:+  $ahead_behind}"
                echo ""
            fi
        fi
    done < <(git worktree list)

    if [[ $wt_count -eq 0 ]]; then
        echo -e "  ${YELLOW}No additional worktrees found.${NC}"
        echo ""
    fi

    # Check for prunable worktrees
    local prunable=$(git worktree list --porcelain | grep -c "prunable" || true)
    if [[ $prunable -gt 0 ]]; then
        echo -e "  ${YELLOW}⚠ $prunable stale worktree(s) detected${NC}"
        echo -e "  Run ${BLUE}nest-wt prune${NC} to clean up"
        echo ""
    fi

    echo "Quick actions:"
    echo "  wt <number>              # Switch to worktree"
    echo "  nest-wt remove <number>  # Remove a worktree"
    echo "  nest-wt prune            # Clean up stale references"
}

wt_remove() {
    cd "$REPO_ROOT"

    if [[ -z "$1" ]]; then
        echo "Usage: nest-wt remove <number|name|path> [more...]"
        echo ""
        wt_list
        return 1
    fi

    local branches_to_delete=()

    # Process each argument
    for input in "$@"; do
        local worktree_path=""

        # Check if input is a number
        if [[ "$input" =~ ^[0-9]+$ ]]; then
            local count=0
            while IFS= read -r line; do
                if [[ -n "$line" ]]; then
                    local path=$(echo "$line" | awk '{print $1}')
                    if [[ "$path" == *".worktrees"* ]]; then
                        count=$((count + 1))
                        if [[ $count -eq $input ]]; then
                            worktree_path="$path"
                            break
                        fi
                    fi
                fi
            done < <(git worktree list)

            if [[ -z "$worktree_path" ]]; then
                print_error "Invalid worktree number: $input"
                continue
            fi
        # Check if input is a name (without path)
        elif [[ ! "$input" == /* ]]; then
            local potential_path="$WORKTREES_DIR/$input"
            if [[ -d "$potential_path" ]]; then
                worktree_path="$potential_path"
            else
                print_error "Worktree not found: $input"
                continue
            fi
        else
            worktree_path="$input"
        fi

        local name=$(basename "$worktree_path")
        local branch=$(cd "$worktree_path" 2>/dev/null && git branch --show-current)

        echo -e "Removing: ${YELLOW}$name${NC}"

        if git worktree remove "$worktree_path" 2>/dev/null; then
            print_success "Removed $name"
            [[ -n "$branch" ]] && branches_to_delete+=("$branch")
        else
            print_error "Failed to remove $name"
        fi
    done

    # Show branches that can be deleted
    if [[ ${#branches_to_delete[@]} -gt 0 ]]; then
        echo ""
        echo -e "Branches still exist. To delete:"
        for branch in "${branches_to_delete[@]}"; do
            echo -e "  ${BLUE}git branch -D $branch${NC}"
        done
    fi
}

wt_prune() {
    cd "$REPO_ROOT"
    echo "Checking for stale worktrees..."
    local stale_worktrees=$(git worktree list --porcelain | grep -B2 "prunable" | grep "worktree" | sed 's/worktree //')

    if [[ -z "$stale_worktrees" ]]; then
        echo "No stale worktrees found."
        return 0
    fi

    echo "Found stale worktrees:"
    echo "$stale_worktrees" | while read -r path; do
        echo "  - $path"
    done

    git worktree prune
    print_success "Pruned all stale worktree references"
}

wt_create() {
    local INPUT="$1"
    local BASE_REF="${2:-}"

    local BRANCH_PREFIX="jordan/"
    local NEW_BRANCH=""
    local WORKTREE_NAME=""

    # Check if input contains a slash (full branch name provided)
    if [[ "$INPUT" == */* ]]; then
        # Full branch name provided (e.g., "alice/feature" or "jordan/my-feature")
        NEW_BRANCH="$INPUT"
        # Convert slashes to dashes for directory name
        WORKTREE_NAME="${INPUT//\//-}"
        print_info "Using full branch name '$NEW_BRANCH' → directory '$WORKTREE_NAME'"
    else
        # Simple name provided, add jordan/ prefix
        WORKTREE_NAME="$INPUT"
        NEW_BRANCH="${BRANCH_PREFIX}${WORKTREE_NAME}"
    fi

    # Validate worktree directory name
    if [[ "$WORKTREE_NAME" =~ [^a-zA-Z0-9_-] ]]; then
        print_error "Worktree name should only contain letters, numbers, hyphens, and underscores"
        exit 1
    fi

    WORKTREE_PATH="$WORKTREES_DIR/$WORKTREE_NAME"

    print_header "Creating Git Worktree: $WORKTREE_NAME"

    # Show path info upfront
    echo -e "Worktree: ${GREEN}$WORKTREE_PATH${NC}"
    echo -e "Branch:   ${GREEN}$NEW_BRANCH${NC}"
    echo ""

    # Check if worktree already exists
    if [[ -d "$WORKTREE_PATH" ]]; then
        print_error "Worktree directory already exists at: $WORKTREE_PATH"
        exit 1
    fi

    # Create worktrees directory if it doesn't exist
    mkdir -p "$WORKTREES_DIR"

    # Fetch latest from remote
    print_info "Fetching latest from origin..."
    cd "$REPO_ROOT"
    git fetch origin

    # =========================================================================
    # Step 1: Create the worktree (smart branch detection)
    # =========================================================================

    print_info "Creating worktree..."

    # Check if branch exists locally
    if git show-ref --verify --quiet "refs/heads/$NEW_BRANCH"; then
        print_info "Using existing local branch '$NEW_BRANCH'"
        if [[ -n "$BASE_REF" ]]; then
            print_warning "Ignoring base-ref '$BASE_REF' (using existing branch)"
        fi
        git worktree add "$WORKTREE_PATH" "$NEW_BRANCH"
        print_success "Created worktree from existing local branch '$NEW_BRANCH'"

    # Check if branch exists on remote
    elif git show-ref --verify --quiet "refs/remotes/origin/$NEW_BRANCH"; then
        print_info "Tracking remote branch 'origin/$NEW_BRANCH'"
        if [[ -n "$BASE_REF" ]]; then
            print_warning "Ignoring base-ref '$BASE_REF' (tracking remote branch)"
        fi
        git worktree add "$WORKTREE_PATH" --track -b "$NEW_BRANCH" "origin/$NEW_BRANCH"
        print_success "Created worktree tracking 'origin/$NEW_BRANCH'"

    # Branch doesn't exist - create new
    else
        if [[ -n "$BASE_REF" ]]; then
            local RESOLVED_REF=""

            # Check if it looks like a version number (e.g., 2.11.0)
            if [[ "$BASE_REF" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                # It's a version number, map to release/X.X.X
                local RELEASE_BRANCH="release/${BASE_REF}"
                if git show-ref --verify --quiet "refs/remotes/origin/$RELEASE_BRANCH"; then
                    RESOLVED_REF="origin/$RELEASE_BRANCH"
                    print_info "Resolved version $BASE_REF to $RESOLVED_REF"
                else
                    print_error "Release branch not found: $RELEASE_BRANCH"
                    print_info "Available release branches:"
                    git branch -r | grep "origin/release/" | head -10
                    exit 1
                fi
            # Check if it's already a remote ref
            elif [[ "$BASE_REF" == origin/* ]]; then
                RESOLVED_REF="$BASE_REF"
            # Check if release/X.X.X exists on remote
            elif git show-ref --verify --quiet "refs/remotes/origin/$BASE_REF"; then
                RESOLVED_REF="origin/$BASE_REF"
            # Check if it exists locally
            elif git show-ref --verify --quiet "refs/heads/$BASE_REF"; then
                RESOLVED_REF="$BASE_REF"
            else
                print_error "Could not find branch: $BASE_REF"
                exit 1
            fi

            # Create new branch from the resolved ref
            git worktree add "$WORKTREE_PATH" -b "$NEW_BRANCH" "$RESOLVED_REF"
            print_success "Created new branch '$NEW_BRANCH' from '$RESOLVED_REF'"
        else
            # No base ref provided - create from current HEAD
            git worktree add "$WORKTREE_PATH" -b "$NEW_BRANCH"
            print_success "Created new branch '$NEW_BRANCH' from HEAD"
        fi
    fi

    # =========================================================================
    # Step 2: Copy local configuration files
    # =========================================================================

    print_header "Copying Local Configuration Files"

    # --- .claude directory ---
    copy_if_exists "$REPO_ROOT/.claude" "$WORKTREE_PATH/.claude" ".claude/ (Claude Code settings)"

    # --- .vscode/settings.json ---
    if [[ -f "$REPO_ROOT/.vscode/settings.json" ]]; then
        mkdir -p "$WORKTREE_PATH/.vscode"
        cp "$REPO_ROOT/.vscode/settings.json" "$WORKTREE_PATH/.vscode/settings.json"
        print_success "Copied .vscode/settings.json"
    fi

    # --- Environment files ---
    print_info "Copying environment files..."

    ENV_FILES=(
        "apps/backend/client-api/.env.local"
        "apps/backend/pdf-generation-service/.env.local"
        "apps/frontend/patient-navigator/.env.local"
        "apps/frontend/provider-portal/.env.local"
    )

    for env_file in "${ENV_FILES[@]}"; do
        copy_if_exists "$REPO_ROOT/$env_file" "$WORKTREE_PATH/$env_file" "$env_file"
    done

    # --- Certificate files (*.pem) ---
    print_info "Copying certificate files..."

    PEM_DIRS=(
        "apps/backend/client-api"
        "apps/frontend/patient-navigator"
        "apps/frontend/provider-portal"
    )

    for pem_dir in "${PEM_DIRS[@]}"; do
        # Copy *.pem files in the app root
        for pem_file in "$REPO_ROOT/$pem_dir"/*.pem; do
            if [[ -f "$pem_file" ]]; then
                filename=$(basename "$pem_file")
                copy_if_exists "$pem_file" "$WORKTREE_PATH/$pem_dir/$filename" "$pem_dir/$filename"
            fi
        done

        # Copy certs/ directory if it exists
        if [[ -d "$REPO_ROOT/$pem_dir/certs" ]]; then
            mkdir -p "$WORKTREE_PATH/$pem_dir/certs"
            cp -r "$REPO_ROOT/$pem_dir/certs/"*.pem "$WORKTREE_PATH/$pem_dir/certs/" 2>/dev/null && \
                print_success "Copied $pem_dir/certs/*.pem" || \
                print_warning "No .pem files in $pem_dir/certs/"
        fi
    done

    # --- .cursor directory ---
    copy_if_exists "$REPO_ROOT/.cursor" "$WORKTREE_PATH/.cursor" ".cursor/ (Cursor IDE settings)"

    # --- .playwright-mcp directory ---
    copy_if_exists "$REPO_ROOT/.playwright-mcp" "$WORKTREE_PATH/.playwright-mcp" ".playwright-mcp/ (Playwright MCP config)"

    # =========================================================================
    # Done - skip pnpm install for speed (user can run manually)
    # =========================================================================

    # =========================================================================
    # Summary
    # =========================================================================

    print_header "Worktree Ready!"

    echo "Next step:"
    echo "  pnpm install                # Install dependencies (required before running)"
    echo ""
    echo "Then:"
    echo "  nx serve provider-portal    # Start Provider Portal"
    echo "  nx serve patient-navigator  # Start Patient Navigator"
    echo "  nx serve client-api         # Start Client API"
    echo ""
}

# =============================================================================
# Main Entry Point
# =============================================================================

case "${1:-}" in
    list)
        wt_list
        ;;
    remove)
        shift
        wt_remove "$@"
        ;;
    prune)
        wt_prune
        ;;
    help|--help|-h)
        show_usage
        ;;
    "")
        show_usage
        exit 1
        ;;
    *)
        wt_create "$@"
        ;;
esac
